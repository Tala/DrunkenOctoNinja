/*
    Copyright (C) 2014 Parrot SA

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in
      the documentation and/or other materials provided with the 
      distribution.
    * Neither the name of Parrot nor the names
      of its contributors may be used to endorse or promote products
      derived from this software without specific prior written
      permission.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
    COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
    INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
    BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
    OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED 
    AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
    OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
    OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGE.
*/
package com.parrot.freeflight3.devicecontrollers;

/**********************************************************
 *            AUTOGENERATED FILE                          *
 *             DO NOT MODIFY IT                           *
 *                                                        *
 * To add new commands :                                  *
 *  - Modify ../Xml/commands.xml file                     *
 *  - Re-run generateDeviceControllerCategories.py script *
 *                                                        *
 **********************************************************/

import com.parrot.arsdk.ardiscovery.ARDiscoveryDeviceService;
import com.parrot.arsdk.arcommands.ARCommand;
import com.parrot.arsdk.arnetwork.ARNETWORK_MANAGER_CALLBACK_RETURN_ENUM;
import com.parrot.arsdk.arcommands.ARCOMMANDS_GENERATOR_ERROR_ENUM;
import com.parrot.arsdk.arsal.ARSALPrint;
import java.util.HashMap;
import android.os.Bundle;
import android.content.Intent;
import android.support.v4.content.LocalBroadcastManager;
import com.parrot.arsdk.arcommands.ARCommandMiniDronePilotingStateFlatTrimChangedListener;
import com.parrot.arsdk.arcommands.ARCommandMiniDronePilotingStateFlyingStateChangedListener;
import com.parrot.arsdk.arcommands.ARCOMMANDS_MINIDRONE_PILOTINGSTATE_FLYINGSTATECHANGED_STATE_ENUM;
import com.parrot.arsdk.arcommands.ARCommandMiniDronePilotingStateAlertStateChangedListener;
import com.parrot.arsdk.arcommands.ARCOMMANDS_MINIDRONE_PILOTINGSTATE_ALERTSTATECHANGED_STATE_ENUM;
import com.parrot.arsdk.arcommands.ARCommandMiniDronePilotingStateAutoTakeOffModeChangedListener;
import com.parrot.arsdk.arcommands.ARCOMMANDS_MINIDRONE_ANIMATIONS_FLIP_DIRECTION_ENUM;
import com.parrot.arsdk.arcommands.ARCommandMiniDroneMediaRecordStatePictureStateChangedListener;
import com.parrot.arsdk.arcommands.ARCommandMiniDronePilotingSettingsStateMaxAltitudeChangedListener;
import com.parrot.arsdk.arcommands.ARCommandMiniDronePilotingSettingsStateMaxTiltChangedListener;
import com.parrot.arsdk.arcommands.ARCommandMiniDroneSpeedSettingsStateMaxVerticalSpeedChangedListener;
import com.parrot.arsdk.arcommands.ARCommandMiniDroneSpeedSettingsStateMaxRotationSpeedChangedListener;
import com.parrot.arsdk.arcommands.ARCommandMiniDroneSpeedSettingsStateWheelsChangedListener;
import com.parrot.arsdk.arcommands.ARCommandMiniDroneSettingsStateProductMotorsVersionChangedListener;
import com.parrot.arsdk.arcommands.ARCommandMiniDroneSettingsStateProductInertialVersionChangedListener;
import com.parrot.arsdk.arcommands.ARCommandMiniDroneSettingsStateCutOutModeChangedListener;
import com.parrot.arsdk.arcommands.ARCommandMiniDroneFloodControlStateFloodControlChangedListener;

public abstract class MiniDroneDeviceControllerAndLibARCommands extends DeviceController implements ARCommandMiniDronePilotingStateFlatTrimChangedListener, ARCommandMiniDronePilotingStateFlyingStateChangedListener, ARCommandMiniDronePilotingStateAlertStateChangedListener, ARCommandMiniDronePilotingStateAutoTakeOffModeChangedListener, ARCommandMiniDroneMediaRecordStatePictureStateChangedListener, ARCommandMiniDronePilotingSettingsStateMaxAltitudeChangedListener, ARCommandMiniDronePilotingSettingsStateMaxTiltChangedListener, ARCommandMiniDroneSpeedSettingsStateMaxVerticalSpeedChangedListener, ARCommandMiniDroneSpeedSettingsStateMaxRotationSpeedChangedListener, ARCommandMiniDroneSpeedSettingsStateWheelsChangedListener, ARCommandMiniDroneSettingsStateProductMotorsVersionChangedListener, ARCommandMiniDroneSettingsStateProductInertialVersionChangedListener, ARCommandMiniDroneSettingsStateCutOutModeChangedListener, ARCommandMiniDroneFloodControlStateFloodControlChangedListener
{
    private final static String MINIDRONEDEVICECONTROLLERANDLIBARCOMMANDS_TAG = "MiniDroneDeviceControllerAndLibARCommands";
    
    private HashMap<String, Intent> miniDroneDeviceControllerAndLibARCommandsIntentCache;
    public final static String MiniDroneDeviceControllerPilotingStateFlatTrimChangedNotification = "MiniDroneDeviceControllerPilotingStateFlatTrimChangedNotification";
    public final static String MiniDroneDeviceControllerPilotingStateFlyingStateChangedNotification = "MiniDroneDeviceControllerPilotingStateFlyingStateChangedNotification";
    public final static String MiniDroneDeviceControllerPilotingStateFlyingStateChangedNotificationStateKey = "MiniDroneDeviceControllerPilotingStateFlyingStateChangedNotificationStateKey";
    public final static String MiniDroneDeviceControllerPilotingStateAlertStateChangedNotification = "MiniDroneDeviceControllerPilotingStateAlertStateChangedNotification";
    public final static String MiniDroneDeviceControllerPilotingStateAlertStateChangedNotificationStateKey = "MiniDroneDeviceControllerPilotingStateAlertStateChangedNotificationStateKey";
    public final static String MiniDroneDeviceControllerPilotingStateAutoTakeOffModeChangedNotification = "MiniDroneDeviceControllerPilotingStateAutoTakeOffModeChangedNotification";
    public final static String MiniDroneDeviceControllerPilotingStateAutoTakeOffModeChangedNotificationStateKey = "MiniDroneDeviceControllerPilotingStateAutoTakeOffModeChangedNotificationStateKey";
    public final static String MiniDroneDeviceControllerMediaRecordStatePictureStateChangedNotification = "MiniDroneDeviceControllerMediaRecordStatePictureStateChangedNotification";
    public final static String MiniDroneDeviceControllerMediaRecordStatePictureStateChangedNotificationStateKey = "MiniDroneDeviceControllerMediaRecordStatePictureStateChangedNotificationStateKey";
    public final static String MiniDroneDeviceControllerMediaRecordStatePictureStateChangedNotificationMass_storage_idKey = "MiniDroneDeviceControllerMediaRecordStatePictureStateChangedNotificationMass_storage_idKey";
    public final static String MiniDroneDeviceControllerPilotingSettingsStateMaxAltitudeChangedNotification = "MiniDroneDeviceControllerPilotingSettingsStateMaxAltitudeChangedNotification";
    public final static String MiniDroneDeviceControllerPilotingSettingsStateMaxAltitudeChangedNotificationCurrentKey = "MiniDroneDeviceControllerPilotingSettingsStateMaxAltitudeChangedNotificationCurrentKey";
    public final static String MiniDroneDeviceControllerPilotingSettingsStateMaxAltitudeChangedNotificationMinKey = "MiniDroneDeviceControllerPilotingSettingsStateMaxAltitudeChangedNotificationMinKey";
    public final static String MiniDroneDeviceControllerPilotingSettingsStateMaxAltitudeChangedNotificationMaxKey = "MiniDroneDeviceControllerPilotingSettingsStateMaxAltitudeChangedNotificationMaxKey";
    public final static String MiniDroneDeviceControllerPilotingSettingsStateMaxTiltChangedNotification = "MiniDroneDeviceControllerPilotingSettingsStateMaxTiltChangedNotification";
    public final static String MiniDroneDeviceControllerPilotingSettingsStateMaxTiltChangedNotificationCurrentKey = "MiniDroneDeviceControllerPilotingSettingsStateMaxTiltChangedNotificationCurrentKey";
    public final static String MiniDroneDeviceControllerPilotingSettingsStateMaxTiltChangedNotificationMinKey = "MiniDroneDeviceControllerPilotingSettingsStateMaxTiltChangedNotificationMinKey";
    public final static String MiniDroneDeviceControllerPilotingSettingsStateMaxTiltChangedNotificationMaxKey = "MiniDroneDeviceControllerPilotingSettingsStateMaxTiltChangedNotificationMaxKey";
    public final static String MiniDroneDeviceControllerSpeedSettingsStateMaxVerticalSpeedChangedNotification = "MiniDroneDeviceControllerSpeedSettingsStateMaxVerticalSpeedChangedNotification";
    public final static String MiniDroneDeviceControllerSpeedSettingsStateMaxVerticalSpeedChangedNotificationCurrentKey = "MiniDroneDeviceControllerSpeedSettingsStateMaxVerticalSpeedChangedNotificationCurrentKey";
    public final static String MiniDroneDeviceControllerSpeedSettingsStateMaxVerticalSpeedChangedNotificationMinKey = "MiniDroneDeviceControllerSpeedSettingsStateMaxVerticalSpeedChangedNotificationMinKey";
    public final static String MiniDroneDeviceControllerSpeedSettingsStateMaxVerticalSpeedChangedNotificationMaxKey = "MiniDroneDeviceControllerSpeedSettingsStateMaxVerticalSpeedChangedNotificationMaxKey";
    public final static String MiniDroneDeviceControllerSpeedSettingsStateMaxRotationSpeedChangedNotification = "MiniDroneDeviceControllerSpeedSettingsStateMaxRotationSpeedChangedNotification";
    public final static String MiniDroneDeviceControllerSpeedSettingsStateMaxRotationSpeedChangedNotificationCurrentKey = "MiniDroneDeviceControllerSpeedSettingsStateMaxRotationSpeedChangedNotificationCurrentKey";
    public final static String MiniDroneDeviceControllerSpeedSettingsStateMaxRotationSpeedChangedNotificationMinKey = "MiniDroneDeviceControllerSpeedSettingsStateMaxRotationSpeedChangedNotificationMinKey";
    public final static String MiniDroneDeviceControllerSpeedSettingsStateMaxRotationSpeedChangedNotificationMaxKey = "MiniDroneDeviceControllerSpeedSettingsStateMaxRotationSpeedChangedNotificationMaxKey";
    public final static String MiniDroneDeviceControllerSpeedSettingsStateWheelsChangedNotification = "MiniDroneDeviceControllerSpeedSettingsStateWheelsChangedNotification";
    public final static String MiniDroneDeviceControllerSpeedSettingsStateWheelsChangedNotificationPresentKey = "MiniDroneDeviceControllerSpeedSettingsStateWheelsChangedNotificationPresentKey";
    public final static String MiniDroneDeviceControllerSettingsStateProductMotorsVersionChangedNotification = "MiniDroneDeviceControllerSettingsStateProductMotorsVersionChangedNotification";
    public final static String MiniDroneDeviceControllerSettingsStateProductMotorsVersionChangedNotificationMotorKey = "MiniDroneDeviceControllerSettingsStateProductMotorsVersionChangedNotificationMotorKey";
    public final static String MiniDroneDeviceControllerSettingsStateProductMotorsVersionChangedNotificationTypeKey = "MiniDroneDeviceControllerSettingsStateProductMotorsVersionChangedNotificationTypeKey";
    public final static String MiniDroneDeviceControllerSettingsStateProductMotorsVersionChangedNotificationSoftwareKey = "MiniDroneDeviceControllerSettingsStateProductMotorsVersionChangedNotificationSoftwareKey";
    public final static String MiniDroneDeviceControllerSettingsStateProductMotorsVersionChangedNotificationHardwareKey = "MiniDroneDeviceControllerSettingsStateProductMotorsVersionChangedNotificationHardwareKey";
    public final static String MiniDroneDeviceControllerSettingsStateProductInertialVersionChangedNotification = "MiniDroneDeviceControllerSettingsStateProductInertialVersionChangedNotification";
    public final static String MiniDroneDeviceControllerSettingsStateProductInertialVersionChangedNotificationSoftwareKey = "MiniDroneDeviceControllerSettingsStateProductInertialVersionChangedNotificationSoftwareKey";
    public final static String MiniDroneDeviceControllerSettingsStateProductInertialVersionChangedNotificationHardwareKey = "MiniDroneDeviceControllerSettingsStateProductInertialVersionChangedNotificationHardwareKey";
    public final static String MiniDroneDeviceControllerSettingsStateCutOutModeChangedNotification = "MiniDroneDeviceControllerSettingsStateCutOutModeChangedNotification";
    public final static String MiniDroneDeviceControllerSettingsStateCutOutModeChangedNotificationEnableKey = "MiniDroneDeviceControllerSettingsStateCutOutModeChangedNotificationEnableKey";
    public final static String MiniDroneDeviceControllerFloodControlStateFloodControlChangedNotification = "MiniDroneDeviceControllerFloodControlStateFloodControlChangedNotification";
    public final static String MiniDroneDeviceControllerFloodControlStateFloodControlChangedNotificationDelayKey = "MiniDroneDeviceControllerFloodControlStateFloodControlChangedNotificationDelayKey";

    protected void initialize ()
    {
        if(!isInitialized())
        {
            initMiniDroneDeviceControllerAndLibARCommandsIntents ();
            super.initialize ();
        }
    }
    
    @Override
    protected void setConfigurations (ARNetworkConfig netConfig, ARDiscoveryDeviceService service, double interval, Class<? extends DeviceController> dcBridgeClass)
    {
        super.setConfigurations (netConfig, service, interval, dcBridgeClass);
    }
    
    @Override
    protected void registerARCommandsListener ()
    {
        super.registerARCommandsListener();
        
        ARCommand.setMiniDronePilotingStateFlatTrimChangedListener (this);
        ARCommand.setMiniDronePilotingStateFlyingStateChangedListener (this);
        ARCommand.setMiniDronePilotingStateAlertStateChangedListener (this);
        ARCommand.setMiniDronePilotingStateAutoTakeOffModeChangedListener (this);
        ARCommand.setMiniDroneMediaRecordStatePictureStateChangedListener (this);
        ARCommand.setMiniDronePilotingSettingsStateMaxAltitudeChangedListener (this);
        ARCommand.setMiniDronePilotingSettingsStateMaxTiltChangedListener (this);
        ARCommand.setMiniDroneSpeedSettingsStateMaxVerticalSpeedChangedListener (this);
        ARCommand.setMiniDroneSpeedSettingsStateMaxRotationSpeedChangedListener (this);
        ARCommand.setMiniDroneSpeedSettingsStateWheelsChangedListener (this);
        ARCommand.setMiniDroneSettingsStateProductMotorsVersionChangedListener (this);
        ARCommand.setMiniDroneSettingsStateProductInertialVersionChangedListener (this);
        ARCommand.setMiniDroneSettingsStateCutOutModeChangedListener (this);
        ARCommand.setMiniDroneFloodControlStateFloodControlChangedListener (this);
    }
    
    @Override
    protected void unregisterARCommandsListener ()
    {
        super.unregisterARCommandsListener();
        
        ARCommand.setMiniDronePilotingStateFlatTrimChangedListener (null);
        ARCommand.setMiniDronePilotingStateFlyingStateChangedListener (null);
        ARCommand.setMiniDronePilotingStateAlertStateChangedListener (null);
        ARCommand.setMiniDronePilotingStateAutoTakeOffModeChangedListener (null);
        ARCommand.setMiniDroneMediaRecordStatePictureStateChangedListener (null);
        ARCommand.setMiniDronePilotingSettingsStateMaxAltitudeChangedListener (null);
        ARCommand.setMiniDronePilotingSettingsStateMaxTiltChangedListener (null);
        ARCommand.setMiniDroneSpeedSettingsStateMaxVerticalSpeedChangedListener (null);
        ARCommand.setMiniDroneSpeedSettingsStateMaxRotationSpeedChangedListener (null);
        ARCommand.setMiniDroneSpeedSettingsStateWheelsChangedListener (null);
        ARCommand.setMiniDroneSettingsStateProductMotorsVersionChangedListener (null);
        ARCommand.setMiniDroneSettingsStateProductInertialVersionChangedListener (null);
        ARCommand.setMiniDroneSettingsStateCutOutModeChangedListener (null);
        ARCommand.setMiniDroneFloodControlStateFloodControlChangedListener (null);
    }
    
    private void initMiniDroneDeviceControllerAndLibARCommandsIntents ()
    {
        miniDroneDeviceControllerAndLibARCommandsIntentCache = new HashMap<String, Intent>(14);
        miniDroneDeviceControllerAndLibARCommandsIntentCache.put(MiniDroneDeviceControllerPilotingStateFlatTrimChangedNotification, new Intent (MiniDroneDeviceControllerPilotingStateFlatTrimChangedNotification));
        miniDroneDeviceControllerAndLibARCommandsIntentCache.put(MiniDroneDeviceControllerPilotingStateFlyingStateChangedNotification, new Intent (MiniDroneDeviceControllerPilotingStateFlyingStateChangedNotification));
        miniDroneDeviceControllerAndLibARCommandsIntentCache.put(MiniDroneDeviceControllerPilotingStateAlertStateChangedNotification, new Intent (MiniDroneDeviceControllerPilotingStateAlertStateChangedNotification));
        miniDroneDeviceControllerAndLibARCommandsIntentCache.put(MiniDroneDeviceControllerPilotingStateAutoTakeOffModeChangedNotification, new Intent (MiniDroneDeviceControllerPilotingStateAutoTakeOffModeChangedNotification));
        miniDroneDeviceControllerAndLibARCommandsIntentCache.put(MiniDroneDeviceControllerMediaRecordStatePictureStateChangedNotification, new Intent (MiniDroneDeviceControllerMediaRecordStatePictureStateChangedNotification));
        miniDroneDeviceControllerAndLibARCommandsIntentCache.put(MiniDroneDeviceControllerPilotingSettingsStateMaxAltitudeChangedNotification, new Intent (MiniDroneDeviceControllerPilotingSettingsStateMaxAltitudeChangedNotification));
        miniDroneDeviceControllerAndLibARCommandsIntentCache.put(MiniDroneDeviceControllerPilotingSettingsStateMaxTiltChangedNotification, new Intent (MiniDroneDeviceControllerPilotingSettingsStateMaxTiltChangedNotification));
        miniDroneDeviceControllerAndLibARCommandsIntentCache.put(MiniDroneDeviceControllerSpeedSettingsStateMaxVerticalSpeedChangedNotification, new Intent (MiniDroneDeviceControllerSpeedSettingsStateMaxVerticalSpeedChangedNotification));
        miniDroneDeviceControllerAndLibARCommandsIntentCache.put(MiniDroneDeviceControllerSpeedSettingsStateMaxRotationSpeedChangedNotification, new Intent (MiniDroneDeviceControllerSpeedSettingsStateMaxRotationSpeedChangedNotification));
        miniDroneDeviceControllerAndLibARCommandsIntentCache.put(MiniDroneDeviceControllerSpeedSettingsStateWheelsChangedNotification, new Intent (MiniDroneDeviceControllerSpeedSettingsStateWheelsChangedNotification));
        miniDroneDeviceControllerAndLibARCommandsIntentCache.put(MiniDroneDeviceControllerSettingsStateProductMotorsVersionChangedNotification, new Intent (MiniDroneDeviceControllerSettingsStateProductMotorsVersionChangedNotification));
        miniDroneDeviceControllerAndLibARCommandsIntentCache.put(MiniDroneDeviceControllerSettingsStateProductInertialVersionChangedNotification, new Intent (MiniDroneDeviceControllerSettingsStateProductInertialVersionChangedNotification));
        miniDroneDeviceControllerAndLibARCommandsIntentCache.put(MiniDroneDeviceControllerSettingsStateCutOutModeChangedNotification, new Intent (MiniDroneDeviceControllerSettingsStateCutOutModeChangedNotification));
        miniDroneDeviceControllerAndLibARCommandsIntentCache.put(MiniDroneDeviceControllerFloodControlStateFloodControlChangedNotification, new Intent (MiniDroneDeviceControllerFloodControlStateFloodControlChangedNotification));
    }
    
    protected Intent getMiniDroneDeviceControllerAndLibARCommandsIntent (String name)
    {
        return miniDroneDeviceControllerAndLibARCommandsIntentCache.get(name) ;
    }
    
    /** Method called in a dedicated thread on a configurable interval.
     * @note This is an abstract method that you must override.
     */
    public abstract void controllerLoop ();
    
    /**
     * Request a stopped controller to start.
     * @note This is an abstract method that you must override.
     */
    public abstract void start ();
    
    /**
     * Request a started controller to stop.
     * @note This is an abstract method that you must override.
     */
    public abstract void stop ();
    
    /**
     * Get the current state of the controller.
     * @return current state
     */
    public abstract DEVICE_CONTROLER_STATE_ENUM getState ();
    
    /**
     * Called when a command <code>FlatTrimChanged</code> of class <code>PilotingState</code> in project <code>MiniDrone</code> is decoded
     */
    @Override
    public synchronized void onMiniDronePilotingStateFlatTrimChangedUpdate ()
    {
        /* dictionary of update */
        Bundle updateDictionary = new Bundle();
        Bundle notificationBundle = new Bundle();
        
        updateDictionary.putBundle(MiniDroneDeviceControllerPilotingStateFlatTrimChangedNotification, notificationBundle);
        
        /* update the NotificationDictionary */
        notificationDictionary.putBundle(MiniDroneDeviceControllerPilotingStateFlatTrimChangedNotification, notificationBundle);
        
        /* send NotificationDictionaryChanged */
        Intent intentDicChanged = new Intent (DeviceControllerNotificationDictionaryChanged);
        intentDicChanged.putExtras (updateDictionary);
        LocalBroadcastManager.getInstance(getApplicationContext()).sendBroadcast(intentDicChanged);
        
        /* send notification dedicated */
        Intent intent = miniDroneDeviceControllerAndLibARCommandsIntentCache.get(MiniDroneDeviceControllerPilotingStateFlatTrimChangedNotification);
        LocalBroadcastManager.getInstance(getApplicationContext()).sendBroadcast(intent);
    }
    
    /**
     * Called when a command <code>FlyingStateChanged</code> of class <code>PilotingState</code> in project <code>MiniDrone</code> is decoded
     * @param state Drone flying state
     */
    @Override
    public synchronized void onMiniDronePilotingStateFlyingStateChangedUpdate (ARCOMMANDS_MINIDRONE_PILOTINGSTATE_FLYINGSTATECHANGED_STATE_ENUM state)
    {
        /* dictionary of update */
        Bundle updateDictionary = new Bundle();
        Bundle notificationBundle = new Bundle();
        notificationBundle.putInt(MiniDroneDeviceControllerPilotingStateFlyingStateChangedNotificationStateKey, (state != null) ? state.getValue() : ARCOMMANDS_MINIDRONE_PILOTINGSTATE_FLYINGSTATECHANGED_STATE_ENUM.ARCOMMANDS_MINIDRONE_PILOTINGSTATE_FLYINGSTATECHANGED_STATE_MAX.getValue());
        if (state == null)
        {
            ARSALPrint.e(MINIDRONEDEVICECONTROLLERANDLIBARCOMMANDS_TAG, "Bad value for argument `state` in FlyingStateChanged command from the device.");
        }
        
        updateDictionary.putBundle(MiniDroneDeviceControllerPilotingStateFlyingStateChangedNotification, notificationBundle);
        
        /* update the NotificationDictionary */
        notificationDictionary.putBundle(MiniDroneDeviceControllerPilotingStateFlyingStateChangedNotification, notificationBundle);
        
        /* send NotificationDictionaryChanged */
        Intent intentDicChanged = new Intent (DeviceControllerNotificationDictionaryChanged);
        intentDicChanged.putExtras (updateDictionary);
        LocalBroadcastManager.getInstance(getApplicationContext()).sendBroadcast(intentDicChanged);
        
        /* send notification dedicated */
        Intent intent = miniDroneDeviceControllerAndLibARCommandsIntentCache.get(MiniDroneDeviceControllerPilotingStateFlyingStateChangedNotification);
        intent.putExtras (notificationBundle);
        LocalBroadcastManager.getInstance(getApplicationContext()).sendBroadcast(intent);
    }
    
    /**
     * Called when a command <code>AlertStateChanged</code> of class <code>PilotingState</code> in project <code>MiniDrone</code> is decoded
     * @param state Drone alert state
     */
    @Override
    public synchronized void onMiniDronePilotingStateAlertStateChangedUpdate (ARCOMMANDS_MINIDRONE_PILOTINGSTATE_ALERTSTATECHANGED_STATE_ENUM state)
    {
        /* dictionary of update */
        Bundle updateDictionary = new Bundle();
        Bundle notificationBundle = new Bundle();
        notificationBundle.putInt(MiniDroneDeviceControllerPilotingStateAlertStateChangedNotificationStateKey, (state != null) ? state.getValue() : ARCOMMANDS_MINIDRONE_PILOTINGSTATE_ALERTSTATECHANGED_STATE_ENUM.ARCOMMANDS_MINIDRONE_PILOTINGSTATE_ALERTSTATECHANGED_STATE_MAX.getValue());
        if (state == null)
        {
            ARSALPrint.e(MINIDRONEDEVICECONTROLLERANDLIBARCOMMANDS_TAG, "Bad value for argument `state` in AlertStateChanged command from the device.");
        }
        
        updateDictionary.putBundle(MiniDroneDeviceControllerPilotingStateAlertStateChangedNotification, notificationBundle);
        
        /* update the NotificationDictionary */
        notificationDictionary.putBundle(MiniDroneDeviceControllerPilotingStateAlertStateChangedNotification, notificationBundle);
        
        /* send NotificationDictionaryChanged */
        Intent intentDicChanged = new Intent (DeviceControllerNotificationDictionaryChanged);
        intentDicChanged.putExtras (updateDictionary);
        LocalBroadcastManager.getInstance(getApplicationContext()).sendBroadcast(intentDicChanged);
        
        /* send notification dedicated */
        Intent intent = miniDroneDeviceControllerAndLibARCommandsIntentCache.get(MiniDroneDeviceControllerPilotingStateAlertStateChangedNotification);
        intent.putExtras (notificationBundle);
        LocalBroadcastManager.getInstance(getApplicationContext()).sendBroadcast(intent);
    }
    
    /**
     * Called when a command <code>AutoTakeOffModeChanged</code> of class <code>PilotingState</code> in project <code>MiniDrone</code> is decoded
     * @param state State of automatic take off mode
     */
    @Override
    public synchronized void onMiniDronePilotingStateAutoTakeOffModeChangedUpdate (byte state)
    {
        /* dictionary of update */
        Bundle updateDictionary = new Bundle();
        Bundle notificationBundle = new Bundle();
        notificationBundle.putByte(MiniDroneDeviceControllerPilotingStateAutoTakeOffModeChangedNotificationStateKey, state);
        
        updateDictionary.putBundle(MiniDroneDeviceControllerPilotingStateAutoTakeOffModeChangedNotification, notificationBundle);
        
        /* update the NotificationDictionary */
        notificationDictionary.putBundle(MiniDroneDeviceControllerPilotingStateAutoTakeOffModeChangedNotification, notificationBundle);
        
        /* send NotificationDictionaryChanged */
        Intent intentDicChanged = new Intent (DeviceControllerNotificationDictionaryChanged);
        intentDicChanged.putExtras (updateDictionary);
        LocalBroadcastManager.getInstance(getApplicationContext()).sendBroadcast(intentDicChanged);
        
        /* send notification dedicated */
        Intent intent = miniDroneDeviceControllerAndLibARCommandsIntentCache.get(MiniDroneDeviceControllerPilotingStateAutoTakeOffModeChangedNotification);
        intent.putExtras (notificationBundle);
        LocalBroadcastManager.getInstance(getApplicationContext()).sendBroadcast(intent);
    }
    
    /**
     * Called when a command <code>PictureStateChanged</code> of class <code>MediaRecordState</code> in project <code>MiniDrone</code> is decoded
     * @param state 1 if picture has been taken, 0 otherwise
     * @param mass_storage_id Mass storage id to record
     */
    @Override
    public synchronized void onMiniDroneMediaRecordStatePictureStateChangedUpdate (byte state, byte mass_storage_id)
    {
        /* dictionary of update */
        Bundle updateDictionary = new Bundle();
        Bundle notificationBundle = new Bundle();
        notificationBundle.putByte(MiniDroneDeviceControllerMediaRecordStatePictureStateChangedNotificationStateKey, state);
        notificationBundle.putByte(MiniDroneDeviceControllerMediaRecordStatePictureStateChangedNotificationMass_storage_idKey, mass_storage_id);
        
        updateDictionary.putBundle(MiniDroneDeviceControllerMediaRecordStatePictureStateChangedNotification, notificationBundle);
        
        /* update the NotificationDictionary */
        notificationDictionary.putBundle(MiniDroneDeviceControllerMediaRecordStatePictureStateChangedNotification, notificationBundle);
        
        /* send NotificationDictionaryChanged */
        Intent intentDicChanged = new Intent (DeviceControllerNotificationDictionaryChanged);
        intentDicChanged.putExtras (updateDictionary);
        LocalBroadcastManager.getInstance(getApplicationContext()).sendBroadcast(intentDicChanged);
        
        /* send notification dedicated */
        Intent intent = miniDroneDeviceControllerAndLibARCommandsIntentCache.get(MiniDroneDeviceControllerMediaRecordStatePictureStateChangedNotification);
        intent.putExtras (notificationBundle);
        LocalBroadcastManager.getInstance(getApplicationContext()).sendBroadcast(intent);
    }
    
    /**
     * Called when a command <code>MaxAltitudeChanged</code> of class <code>PilotingSettingsState</code> in project <code>MiniDrone</code> is decoded
     * @param current Current altitude max
     * @param min Range min of altitude
     * @param max Range max of altitude
     */
    @Override
    public synchronized void onMiniDronePilotingSettingsStateMaxAltitudeChangedUpdate (float current, float min, float max)
    {
        /* dictionary of update */
        Bundle updateDictionary = new Bundle();
        Bundle notificationBundle = new Bundle();
        notificationBundle.putFloat(MiniDroneDeviceControllerPilotingSettingsStateMaxAltitudeChangedNotificationCurrentKey, current);
        notificationBundle.putFloat(MiniDroneDeviceControllerPilotingSettingsStateMaxAltitudeChangedNotificationMinKey, min);
        notificationBundle.putFloat(MiniDroneDeviceControllerPilotingSettingsStateMaxAltitudeChangedNotificationMaxKey, max);
        
        updateDictionary.putBundle(MiniDroneDeviceControllerPilotingSettingsStateMaxAltitudeChangedNotification, notificationBundle);
        
        /* update the NotificationDictionary */
        notificationDictionary.putBundle(MiniDroneDeviceControllerPilotingSettingsStateMaxAltitudeChangedNotification, notificationBundle);
        
        /* send NotificationDictionaryChanged */
        Intent intentDicChanged = new Intent (DeviceControllerNotificationDictionaryChanged);
        intentDicChanged.putExtras (updateDictionary);
        LocalBroadcastManager.getInstance(getApplicationContext()).sendBroadcast(intentDicChanged);
        
        /* send notification dedicated */
        Intent intent = miniDroneDeviceControllerAndLibARCommandsIntentCache.get(MiniDroneDeviceControllerPilotingSettingsStateMaxAltitudeChangedNotification);
        intent.putExtras (notificationBundle);
        LocalBroadcastManager.getInstance(getApplicationContext()).sendBroadcast(intent);
    }
    
    /**
     * Called when a command <code>MaxTiltChanged</code> of class <code>PilotingSettingsState</code> in project <code>MiniDrone</code> is decoded
     * @param current Current max tilt
     * @param min Range min of tilt
     * @param max Range max of tilt
     */
    @Override
    public synchronized void onMiniDronePilotingSettingsStateMaxTiltChangedUpdate (float current, float min, float max)
    {
        /* dictionary of update */
        Bundle updateDictionary = new Bundle();
        Bundle notificationBundle = new Bundle();
        notificationBundle.putFloat(MiniDroneDeviceControllerPilotingSettingsStateMaxTiltChangedNotificationCurrentKey, current);
        notificationBundle.putFloat(MiniDroneDeviceControllerPilotingSettingsStateMaxTiltChangedNotificationMinKey, min);
        notificationBundle.putFloat(MiniDroneDeviceControllerPilotingSettingsStateMaxTiltChangedNotificationMaxKey, max);
        
        updateDictionary.putBundle(MiniDroneDeviceControllerPilotingSettingsStateMaxTiltChangedNotification, notificationBundle);
        
        /* update the NotificationDictionary */
        notificationDictionary.putBundle(MiniDroneDeviceControllerPilotingSettingsStateMaxTiltChangedNotification, notificationBundle);
        
        /* send NotificationDictionaryChanged */
        Intent intentDicChanged = new Intent (DeviceControllerNotificationDictionaryChanged);
        intentDicChanged.putExtras (updateDictionary);
        LocalBroadcastManager.getInstance(getApplicationContext()).sendBroadcast(intentDicChanged);
        
        /* send notification dedicated */
        Intent intent = miniDroneDeviceControllerAndLibARCommandsIntentCache.get(MiniDroneDeviceControllerPilotingSettingsStateMaxTiltChangedNotification);
        intent.putExtras (notificationBundle);
        LocalBroadcastManager.getInstance(getApplicationContext()).sendBroadcast(intent);
    }
    
    /**
     * Called when a command <code>MaxVerticalSpeedChanged</code> of class <code>SpeedSettingsState</code> in project <code>MiniDrone</code> is decoded
     * @param current Current max vertical speed in m/s
     * @param min Range min of vertical speed
     * @param max Range max of vertical speed
     */
    @Override
    public synchronized void onMiniDroneSpeedSettingsStateMaxVerticalSpeedChangedUpdate (float current, float min, float max)
    {
        /* dictionary of update */
        Bundle updateDictionary = new Bundle();
        Bundle notificationBundle = new Bundle();
        notificationBundle.putFloat(MiniDroneDeviceControllerSpeedSettingsStateMaxVerticalSpeedChangedNotificationCurrentKey, current);
        notificationBundle.putFloat(MiniDroneDeviceControllerSpeedSettingsStateMaxVerticalSpeedChangedNotificationMinKey, min);
        notificationBundle.putFloat(MiniDroneDeviceControllerSpeedSettingsStateMaxVerticalSpeedChangedNotificationMaxKey, max);
        
        updateDictionary.putBundle(MiniDroneDeviceControllerSpeedSettingsStateMaxVerticalSpeedChangedNotification, notificationBundle);
        
        /* update the NotificationDictionary */
        notificationDictionary.putBundle(MiniDroneDeviceControllerSpeedSettingsStateMaxVerticalSpeedChangedNotification, notificationBundle);
        
        /* send NotificationDictionaryChanged */
        Intent intentDicChanged = new Intent (DeviceControllerNotificationDictionaryChanged);
        intentDicChanged.putExtras (updateDictionary);
        LocalBroadcastManager.getInstance(getApplicationContext()).sendBroadcast(intentDicChanged);
        
        /* send notification dedicated */
        Intent intent = miniDroneDeviceControllerAndLibARCommandsIntentCache.get(MiniDroneDeviceControllerSpeedSettingsStateMaxVerticalSpeedChangedNotification);
        intent.putExtras (notificationBundle);
        LocalBroadcastManager.getInstance(getApplicationContext()).sendBroadcast(intent);
    }
    
    /**
     * Called when a command <code>MaxRotationSpeedChanged</code> of class <code>SpeedSettingsState</code> in project <code>MiniDrone</code> is decoded
     * @param current Current max rotation speed in degree/s
     * @param min Range min of rotation speed
     * @param max Range max of rotation speed
     */
    @Override
    public synchronized void onMiniDroneSpeedSettingsStateMaxRotationSpeedChangedUpdate (float current, float min, float max)
    {
        /* dictionary of update */
        Bundle updateDictionary = new Bundle();
        Bundle notificationBundle = new Bundle();
        notificationBundle.putFloat(MiniDroneDeviceControllerSpeedSettingsStateMaxRotationSpeedChangedNotificationCurrentKey, current);
        notificationBundle.putFloat(MiniDroneDeviceControllerSpeedSettingsStateMaxRotationSpeedChangedNotificationMinKey, min);
        notificationBundle.putFloat(MiniDroneDeviceControllerSpeedSettingsStateMaxRotationSpeedChangedNotificationMaxKey, max);
        
        updateDictionary.putBundle(MiniDroneDeviceControllerSpeedSettingsStateMaxRotationSpeedChangedNotification, notificationBundle);
        
        /* update the NotificationDictionary */
        notificationDictionary.putBundle(MiniDroneDeviceControllerSpeedSettingsStateMaxRotationSpeedChangedNotification, notificationBundle);
        
        /* send NotificationDictionaryChanged */
        Intent intentDicChanged = new Intent (DeviceControllerNotificationDictionaryChanged);
        intentDicChanged.putExtras (updateDictionary);
        LocalBroadcastManager.getInstance(getApplicationContext()).sendBroadcast(intentDicChanged);
        
        /* send notification dedicated */
        Intent intent = miniDroneDeviceControllerAndLibARCommandsIntentCache.get(MiniDroneDeviceControllerSpeedSettingsStateMaxRotationSpeedChangedNotification);
        intent.putExtras (notificationBundle);
        LocalBroadcastManager.getInstance(getApplicationContext()).sendBroadcast(intent);
    }
    
    /**
     * Called when a command <code>WheelsChanged</code> of class <code>SpeedSettingsState</code> in project <code>MiniDrone</code> is decoded
     * @param present 1 if present, 0 if not present
     */
    @Override
    public synchronized void onMiniDroneSpeedSettingsStateWheelsChangedUpdate (byte present)
    {
        /* dictionary of update */
        Bundle updateDictionary = new Bundle();
        Bundle notificationBundle = new Bundle();
        notificationBundle.putByte(MiniDroneDeviceControllerSpeedSettingsStateWheelsChangedNotificationPresentKey, present);
        
        updateDictionary.putBundle(MiniDroneDeviceControllerSpeedSettingsStateWheelsChangedNotification, notificationBundle);
        
        /* update the NotificationDictionary */
        notificationDictionary.putBundle(MiniDroneDeviceControllerSpeedSettingsStateWheelsChangedNotification, notificationBundle);
        
        /* send NotificationDictionaryChanged */
        Intent intentDicChanged = new Intent (DeviceControllerNotificationDictionaryChanged);
        intentDicChanged.putExtras (updateDictionary);
        LocalBroadcastManager.getInstance(getApplicationContext()).sendBroadcast(intentDicChanged);
        
        /* send notification dedicated */
        Intent intent = miniDroneDeviceControllerAndLibARCommandsIntentCache.get(MiniDroneDeviceControllerSpeedSettingsStateWheelsChangedNotification);
        intent.putExtras (notificationBundle);
        LocalBroadcastManager.getInstance(getApplicationContext()).sendBroadcast(intent);
    }
    
    /**
     * Called when a command <code>ProductMotorsVersionChanged</code> of class <code>SettingsState</code> in project <code>MiniDrone</code> is decoded
     * @param motor Product Motor number [1 - 4]
     * @param type Product Motor type
     * @param software Product Motors software version
     * @param hardware Product Motors hardware version
     */
    @Override
    public synchronized void onMiniDroneSettingsStateProductMotorsVersionChangedUpdate (byte motor, String type, String software, String hardware)
    {
        /* dictionary of update */
        Bundle updateDictionary = new Bundle();
        Bundle notificationBundle = new Bundle();
        notificationBundle.putByte(MiniDroneDeviceControllerSettingsStateProductMotorsVersionChangedNotificationMotorKey, motor);
        notificationBundle.putString(MiniDroneDeviceControllerSettingsStateProductMotorsVersionChangedNotificationTypeKey, type);
        notificationBundle.putString(MiniDroneDeviceControllerSettingsStateProductMotorsVersionChangedNotificationSoftwareKey, software);
        notificationBundle.putString(MiniDroneDeviceControllerSettingsStateProductMotorsVersionChangedNotificationHardwareKey, hardware);
        
        updateDictionary.putBundle(MiniDroneDeviceControllerSettingsStateProductMotorsVersionChangedNotification, notificationBundle);
        
        /* update the NotificationDictionary */
        notificationDictionary.putBundle(MiniDroneDeviceControllerSettingsStateProductMotorsVersionChangedNotification, notificationBundle);
        
        /* send NotificationDictionaryChanged */
        Intent intentDicChanged = new Intent (DeviceControllerNotificationDictionaryChanged);
        intentDicChanged.putExtras (updateDictionary);
        LocalBroadcastManager.getInstance(getApplicationContext()).sendBroadcast(intentDicChanged);
        
        /* send notification dedicated */
        Intent intent = miniDroneDeviceControllerAndLibARCommandsIntentCache.get(MiniDroneDeviceControllerSettingsStateProductMotorsVersionChangedNotification);
        intent.putExtras (notificationBundle);
        LocalBroadcastManager.getInstance(getApplicationContext()).sendBroadcast(intent);
    }
    
    /**
     * Called when a command <code>ProductInertialVersionChanged</code> of class <code>SettingsState</code> in project <code>MiniDrone</code> is decoded
     * @param software Product Inertial software version
     * @param hardware Product Inertial hardware version
     */
    @Override
    public synchronized void onMiniDroneSettingsStateProductInertialVersionChangedUpdate (String software, String hardware)
    {
        /* dictionary of update */
        Bundle updateDictionary = new Bundle();
        Bundle notificationBundle = new Bundle();
        notificationBundle.putString(MiniDroneDeviceControllerSettingsStateProductInertialVersionChangedNotificationSoftwareKey, software);
        notificationBundle.putString(MiniDroneDeviceControllerSettingsStateProductInertialVersionChangedNotificationHardwareKey, hardware);
        
        updateDictionary.putBundle(MiniDroneDeviceControllerSettingsStateProductInertialVersionChangedNotification, notificationBundle);
        
        /* update the NotificationDictionary */
        notificationDictionary.putBundle(MiniDroneDeviceControllerSettingsStateProductInertialVersionChangedNotification, notificationBundle);
        
        /* send NotificationDictionaryChanged */
        Intent intentDicChanged = new Intent (DeviceControllerNotificationDictionaryChanged);
        intentDicChanged.putExtras (updateDictionary);
        LocalBroadcastManager.getInstance(getApplicationContext()).sendBroadcast(intentDicChanged);
        
        /* send notification dedicated */
        Intent intent = miniDroneDeviceControllerAndLibARCommandsIntentCache.get(MiniDroneDeviceControllerSettingsStateProductInertialVersionChangedNotification);
        intent.putExtras (notificationBundle);
        LocalBroadcastManager.getInstance(getApplicationContext()).sendBroadcast(intent);
    }
    
    /**
     * Called when a command <code>CutOutModeChanged</code> of class <code>SettingsState</code> in project <code>MiniDrone</code> is decoded
     * @param enable State of cut out mode (1 if is activate, 0 otherwise)
     */
    @Override
    public synchronized void onMiniDroneSettingsStateCutOutModeChangedUpdate (byte enable)
    {
        /* dictionary of update */
        Bundle updateDictionary = new Bundle();
        Bundle notificationBundle = new Bundle();
        notificationBundle.putByte(MiniDroneDeviceControllerSettingsStateCutOutModeChangedNotificationEnableKey, enable);
        
        updateDictionary.putBundle(MiniDroneDeviceControllerSettingsStateCutOutModeChangedNotification, notificationBundle);
        
        /* update the NotificationDictionary */
        notificationDictionary.putBundle(MiniDroneDeviceControllerSettingsStateCutOutModeChangedNotification, notificationBundle);
        
        /* send NotificationDictionaryChanged */
        Intent intentDicChanged = new Intent (DeviceControllerNotificationDictionaryChanged);
        intentDicChanged.putExtras (updateDictionary);
        LocalBroadcastManager.getInstance(getApplicationContext()).sendBroadcast(intentDicChanged);
        
        /* send notification dedicated */
        Intent intent = miniDroneDeviceControllerAndLibARCommandsIntentCache.get(MiniDroneDeviceControllerSettingsStateCutOutModeChangedNotification);
        intent.putExtras (notificationBundle);
        LocalBroadcastManager.getInstance(getApplicationContext()).sendBroadcast(intent);
    }
    
    /**
     * Called when a command <code>FloodControlChanged</code> of class <code>FloodControlState</code> in project <code>MiniDrone</code> is decoded
     * @param delay Delay (in ms) between two PCMD
     */
    @Override
    public synchronized void onMiniDroneFloodControlStateFloodControlChangedUpdate (short delay)
    {
        /* dictionary of update */
        Bundle updateDictionary = new Bundle();
        Bundle notificationBundle = new Bundle();
        notificationBundle.putShort(MiniDroneDeviceControllerFloodControlStateFloodControlChangedNotificationDelayKey, delay);
        
        updateDictionary.putBundle(MiniDroneDeviceControllerFloodControlStateFloodControlChangedNotification, notificationBundle);
        
        /* update the NotificationDictionary */
        notificationDictionary.putBundle(MiniDroneDeviceControllerFloodControlStateFloodControlChangedNotification, notificationBundle);
        
        /* send NotificationDictionaryChanged */
        Intent intentDicChanged = new Intent (DeviceControllerNotificationDictionaryChanged);
        intentDicChanged.putExtras (updateDictionary);
        LocalBroadcastManager.getInstance(getApplicationContext()).sendBroadcast(intentDicChanged);
        
        /* send notification dedicated */
        Intent intent = miniDroneDeviceControllerAndLibARCommandsIntentCache.get(MiniDroneDeviceControllerFloodControlStateFloodControlChangedNotification);
        intent.putExtras (notificationBundle);
        LocalBroadcastManager.getInstance(getApplicationContext()).sendBroadcast(intent);
    }
    
    /**
     * Send a command <code>FlatTrim</code> of class <code>Piloting</code> in project <code>MiniDrone</code>
     * @param bufferId id of the network buffer used to send
     * @param timeoutPolicy policy when sending timeout
     */
    protected boolean MiniDroneDeviceController_SendPilotingFlatTrim (int bufferId, ARNETWORK_MANAGER_CALLBACK_RETURN_ENUM timeoutPolicy, NetworkNotificationData notificationData)
    {
        ARCOMMANDS_GENERATOR_ERROR_ENUM cmdError = ARCOMMANDS_GENERATOR_ERROR_ENUM.ARCOMMANDS_GENERATOR_OK;
        boolean sentStatus = false;
        ARCommand cmd = new ARCommand();
        
        cmdError = cmd.setMiniDronePilotingFlatTrim ();
        if (cmdError == ARCOMMANDS_GENERATOR_ERROR_ENUM.ARCOMMANDS_GENERATOR_OK)
        {
            /** send the command */
            sentStatus = sendData (cmd, bufferId, timeoutPolicy, notificationData);
            cmd.dispose();
        }
        
        if (sentStatus == false)
        {
            ARSALPrint.e(MINIDRONEDEVICECONTROLLERANDLIBARCOMMANDS_TAG, "Failed to send FlatTrim command.");
        }
        
        return sentStatus;
    }
    
    /**
     * Send a command <code>TakeOff</code> of class <code>Piloting</code> in project <code>MiniDrone</code>
     * @param bufferId id of the network buffer used to send
     * @param timeoutPolicy policy when sending timeout
     */
    protected boolean MiniDroneDeviceController_SendPilotingTakeOff (int bufferId, ARNETWORK_MANAGER_CALLBACK_RETURN_ENUM timeoutPolicy, NetworkNotificationData notificationData)
    {
        ARCOMMANDS_GENERATOR_ERROR_ENUM cmdError = ARCOMMANDS_GENERATOR_ERROR_ENUM.ARCOMMANDS_GENERATOR_OK;
        boolean sentStatus = false;
        ARCommand cmd = new ARCommand();
        
        cmdError = cmd.setMiniDronePilotingTakeOff ();
        if (cmdError == ARCOMMANDS_GENERATOR_ERROR_ENUM.ARCOMMANDS_GENERATOR_OK)
        {
            /** send the command */
            sentStatus = sendData (cmd, bufferId, timeoutPolicy, notificationData);
            cmd.dispose();
        }
        
        if (sentStatus == false)
        {
            ARSALPrint.e(MINIDRONEDEVICECONTROLLERANDLIBARCOMMANDS_TAG, "Failed to send TakeOff command.");
        }
        
        return sentStatus;
    }
    
    /**
     * Send a command <code>PCMD</code> of class <code>Piloting</code> in project <code>MiniDrone</code>
     * @param bufferId id of the network buffer used to send
     * @param timeoutPolicy policy when sending timeout
     * @param flag Boolean flag to activate roll/pitch movement
     * @param roll Roll consign for the MiniDrone [-100;100]
     * @param pitch Pitch consign for the MiniDrone [-100;100]
     * @param yaw Yaw consign for the MiniDrone [-100;100]
     * @param gaz Gaz consign for the MiniDrone [-100;100]
     * @param psi Magnetic north heading of the controlling device (deg) [-360;360]
     */
    protected boolean MiniDroneDeviceController_SendPilotingPCMD (int bufferId, ARNETWORK_MANAGER_CALLBACK_RETURN_ENUM timeoutPolicy, NetworkNotificationData notificationData, byte flag, byte roll, byte pitch, byte yaw, byte gaz, float psi)
    {
        ARCOMMANDS_GENERATOR_ERROR_ENUM cmdError = ARCOMMANDS_GENERATOR_ERROR_ENUM.ARCOMMANDS_GENERATOR_OK;
        boolean sentStatus = false;
        ARCommand cmd = new ARCommand();
        
        cmdError = cmd.setMiniDronePilotingPCMD (flag, roll, pitch, yaw, gaz, psi);
        if (cmdError == ARCOMMANDS_GENERATOR_ERROR_ENUM.ARCOMMANDS_GENERATOR_OK)
        {
            /** send the command */
            sentStatus = sendData (cmd, bufferId, timeoutPolicy, notificationData);
            cmd.dispose();
        }
        
        if (sentStatus == false)
        {
            ARSALPrint.e(MINIDRONEDEVICECONTROLLERANDLIBARCOMMANDS_TAG, "Failed to send PCMD command.");
        }
        
        return sentStatus;
    }
    
    /**
     * Send a command <code>Landing</code> of class <code>Piloting</code> in project <code>MiniDrone</code>
     * @param bufferId id of the network buffer used to send
     * @param timeoutPolicy policy when sending timeout
     */
    protected boolean MiniDroneDeviceController_SendPilotingLanding (int bufferId, ARNETWORK_MANAGER_CALLBACK_RETURN_ENUM timeoutPolicy, NetworkNotificationData notificationData)
    {
        ARCOMMANDS_GENERATOR_ERROR_ENUM cmdError = ARCOMMANDS_GENERATOR_ERROR_ENUM.ARCOMMANDS_GENERATOR_OK;
        boolean sentStatus = false;
        ARCommand cmd = new ARCommand();
        
        cmdError = cmd.setMiniDronePilotingLanding ();
        if (cmdError == ARCOMMANDS_GENERATOR_ERROR_ENUM.ARCOMMANDS_GENERATOR_OK)
        {
            /** send the command */
            sentStatus = sendData (cmd, bufferId, timeoutPolicy, notificationData);
            cmd.dispose();
        }
        
        if (sentStatus == false)
        {
            ARSALPrint.e(MINIDRONEDEVICECONTROLLERANDLIBARCOMMANDS_TAG, "Failed to send Landing command.");
        }
        
        return sentStatus;
    }
    
    /**
     * Send a command <code>Emergency</code> of class <code>Piloting</code> in project <code>MiniDrone</code>
     * @param bufferId id of the network buffer used to send
     * @param timeoutPolicy policy when sending timeout
     */
    protected boolean MiniDroneDeviceController_SendPilotingEmergency (int bufferId, ARNETWORK_MANAGER_CALLBACK_RETURN_ENUM timeoutPolicy, NetworkNotificationData notificationData)
    {
        ARCOMMANDS_GENERATOR_ERROR_ENUM cmdError = ARCOMMANDS_GENERATOR_ERROR_ENUM.ARCOMMANDS_GENERATOR_OK;
        boolean sentStatus = false;
        ARCommand cmd = new ARCommand();
        
        cmdError = cmd.setMiniDronePilotingEmergency ();
        if (cmdError == ARCOMMANDS_GENERATOR_ERROR_ENUM.ARCOMMANDS_GENERATOR_OK)
        {
            /** send the command */
            sentStatus = sendData (cmd, bufferId, timeoutPolicy, notificationData);
            cmd.dispose();
        }
        
        if (sentStatus == false)
        {
            ARSALPrint.e(MINIDRONEDEVICECONTROLLERANDLIBARCOMMANDS_TAG, "Failed to send Emergency command.");
        }
        
        return sentStatus;
    }
    
    /**
     * Send a command <code>AutoTakeOffMode</code> of class <code>Piloting</code> in project <code>MiniDrone</code>
     * @param bufferId id of the network buffer used to send
     * @param timeoutPolicy policy when sending timeout
     * @param state State of automatic take off mode
     */
    protected boolean MiniDroneDeviceController_SendPilotingAutoTakeOffMode (int bufferId, ARNETWORK_MANAGER_CALLBACK_RETURN_ENUM timeoutPolicy, NetworkNotificationData notificationData, byte state)
    {
        ARCOMMANDS_GENERATOR_ERROR_ENUM cmdError = ARCOMMANDS_GENERATOR_ERROR_ENUM.ARCOMMANDS_GENERATOR_OK;
        boolean sentStatus = false;
        ARCommand cmd = new ARCommand();
        
        cmdError = cmd.setMiniDronePilotingAutoTakeOffMode (state);
        if (cmdError == ARCOMMANDS_GENERATOR_ERROR_ENUM.ARCOMMANDS_GENERATOR_OK)
        {
            /** send the command */
            sentStatus = sendData (cmd, bufferId, timeoutPolicy, notificationData);
            cmd.dispose();
        }
        
        if (sentStatus == false)
        {
            ARSALPrint.e(MINIDRONEDEVICECONTROLLERANDLIBARCOMMANDS_TAG, "Failed to send AutoTakeOffMode command.");
        }
        
        return sentStatus;
    }
    
    /**
     * Send a command <code>Flip</code> of class <code>Animations</code> in project <code>MiniDrone</code>
     * @param bufferId id of the network buffer used to send
     * @param timeoutPolicy policy when sending timeout
     * @param direction Direction for the flip
     */
    protected boolean MiniDroneDeviceController_SendAnimationsFlip (int bufferId, ARNETWORK_MANAGER_CALLBACK_RETURN_ENUM timeoutPolicy, NetworkNotificationData notificationData, ARCOMMANDS_MINIDRONE_ANIMATIONS_FLIP_DIRECTION_ENUM direction)
    {
        ARCOMMANDS_GENERATOR_ERROR_ENUM cmdError = ARCOMMANDS_GENERATOR_ERROR_ENUM.ARCOMMANDS_GENERATOR_OK;
        boolean sentStatus = false;
        ARCommand cmd = new ARCommand();
        
        cmdError = cmd.setMiniDroneAnimationsFlip (direction);
        if (cmdError == ARCOMMANDS_GENERATOR_ERROR_ENUM.ARCOMMANDS_GENERATOR_OK)
        {
            /** send the command */
            sentStatus = sendData (cmd, bufferId, timeoutPolicy, notificationData);
            cmd.dispose();
        }
        
        if (sentStatus == false)
        {
            ARSALPrint.e(MINIDRONEDEVICECONTROLLERANDLIBARCOMMANDS_TAG, "Failed to send Flip command.");
        }
        
        return sentStatus;
    }
    
    /**
     * Send a command <code>Cap</code> of class <code>Animations</code> in project <code>MiniDrone</code>
     * @param bufferId id of the network buffer used to send
     * @param timeoutPolicy policy when sending timeout
     * @param offset Change the cap with offset angle [-180;180]
     */
    protected boolean MiniDroneDeviceController_SendAnimationsCap (int bufferId, ARNETWORK_MANAGER_CALLBACK_RETURN_ENUM timeoutPolicy, NetworkNotificationData notificationData, short offset)
    {
        ARCOMMANDS_GENERATOR_ERROR_ENUM cmdError = ARCOMMANDS_GENERATOR_ERROR_ENUM.ARCOMMANDS_GENERATOR_OK;
        boolean sentStatus = false;
        ARCommand cmd = new ARCommand();
        
        cmdError = cmd.setMiniDroneAnimationsCap (offset);
        if (cmdError == ARCOMMANDS_GENERATOR_ERROR_ENUM.ARCOMMANDS_GENERATOR_OK)
        {
            /** send the command */
            sentStatus = sendData (cmd, bufferId, timeoutPolicy, notificationData);
            cmd.dispose();
        }
        
        if (sentStatus == false)
        {
            ARSALPrint.e(MINIDRONEDEVICECONTROLLERANDLIBARCOMMANDS_TAG, "Failed to send Cap command.");
        }
        
        return sentStatus;
    }
    
    /**
     * Send a command <code>Picture</code> of class <code>MediaRecord</code> in project <code>MiniDrone</code>
     * @param bufferId id of the network buffer used to send
     * @param timeoutPolicy policy when sending timeout
     * @param mass_storage_id Mass storage id to take picture
     */
    protected boolean MiniDroneDeviceController_SendMediaRecordPicture (int bufferId, ARNETWORK_MANAGER_CALLBACK_RETURN_ENUM timeoutPolicy, NetworkNotificationData notificationData, byte mass_storage_id)
    {
        ARCOMMANDS_GENERATOR_ERROR_ENUM cmdError = ARCOMMANDS_GENERATOR_ERROR_ENUM.ARCOMMANDS_GENERATOR_OK;
        boolean sentStatus = false;
        ARCommand cmd = new ARCommand();
        
        cmdError = cmd.setMiniDroneMediaRecordPicture (mass_storage_id);
        if (cmdError == ARCOMMANDS_GENERATOR_ERROR_ENUM.ARCOMMANDS_GENERATOR_OK)
        {
            /** send the command */
            sentStatus = sendData (cmd, bufferId, timeoutPolicy, notificationData);
            cmd.dispose();
        }
        
        if (sentStatus == false)
        {
            ARSALPrint.e(MINIDRONEDEVICECONTROLLERANDLIBARCOMMANDS_TAG, "Failed to send Picture command.");
        }
        
        return sentStatus;
    }
    
    /**
     * Send a command <code>MaxAltitude</code> of class <code>PilotingSettings</code> in project <code>MiniDrone</code>
     * @param bufferId id of the network buffer used to send
     * @param timeoutPolicy policy when sending timeout
     * @param current Current altitude max in m
     */
    protected boolean MiniDroneDeviceController_SendPilotingSettingsMaxAltitude (int bufferId, ARNETWORK_MANAGER_CALLBACK_RETURN_ENUM timeoutPolicy, NetworkNotificationData notificationData, float current)
    {
        ARCOMMANDS_GENERATOR_ERROR_ENUM cmdError = ARCOMMANDS_GENERATOR_ERROR_ENUM.ARCOMMANDS_GENERATOR_OK;
        boolean sentStatus = false;
        ARCommand cmd = new ARCommand();
        
        cmdError = cmd.setMiniDronePilotingSettingsMaxAltitude (current);
        if (cmdError == ARCOMMANDS_GENERATOR_ERROR_ENUM.ARCOMMANDS_GENERATOR_OK)
        {
            /** send the command */
            sentStatus = sendData (cmd, bufferId, timeoutPolicy, notificationData);
            cmd.dispose();
        }
        
        if (sentStatus == false)
        {
            ARSALPrint.e(MINIDRONEDEVICECONTROLLERANDLIBARCOMMANDS_TAG, "Failed to send MaxAltitude command.");
        }
        
        return sentStatus;
    }
    
    /**
     * Send a command <code>MaxTilt</code> of class <code>PilotingSettings</code> in project <code>MiniDrone</code>
     * @param bufferId id of the network buffer used to send
     * @param timeoutPolicy policy when sending timeout
     * @param current Current tilt max in degree
     */
    protected boolean MiniDroneDeviceController_SendPilotingSettingsMaxTilt (int bufferId, ARNETWORK_MANAGER_CALLBACK_RETURN_ENUM timeoutPolicy, NetworkNotificationData notificationData, float current)
    {
        ARCOMMANDS_GENERATOR_ERROR_ENUM cmdError = ARCOMMANDS_GENERATOR_ERROR_ENUM.ARCOMMANDS_GENERATOR_OK;
        boolean sentStatus = false;
        ARCommand cmd = new ARCommand();
        
        cmdError = cmd.setMiniDronePilotingSettingsMaxTilt (current);
        if (cmdError == ARCOMMANDS_GENERATOR_ERROR_ENUM.ARCOMMANDS_GENERATOR_OK)
        {
            /** send the command */
            sentStatus = sendData (cmd, bufferId, timeoutPolicy, notificationData);
            cmd.dispose();
        }
        
        if (sentStatus == false)
        {
            ARSALPrint.e(MINIDRONEDEVICECONTROLLERANDLIBARCOMMANDS_TAG, "Failed to send MaxTilt command.");
        }
        
        return sentStatus;
    }
    
    /**
     * Send a command <code>MaxVerticalSpeed</code> of class <code>SpeedSettings</code> in project <code>MiniDrone</code>
     * @param bufferId id of the network buffer used to send
     * @param timeoutPolicy policy when sending timeout
     * @param current Current max vertical speed in m/s
     */
    protected boolean MiniDroneDeviceController_SendSpeedSettingsMaxVerticalSpeed (int bufferId, ARNETWORK_MANAGER_CALLBACK_RETURN_ENUM timeoutPolicy, NetworkNotificationData notificationData, float current)
    {
        ARCOMMANDS_GENERATOR_ERROR_ENUM cmdError = ARCOMMANDS_GENERATOR_ERROR_ENUM.ARCOMMANDS_GENERATOR_OK;
        boolean sentStatus = false;
        ARCommand cmd = new ARCommand();
        
        cmdError = cmd.setMiniDroneSpeedSettingsMaxVerticalSpeed (current);
        if (cmdError == ARCOMMANDS_GENERATOR_ERROR_ENUM.ARCOMMANDS_GENERATOR_OK)
        {
            /** send the command */
            sentStatus = sendData (cmd, bufferId, timeoutPolicy, notificationData);
            cmd.dispose();
        }
        
        if (sentStatus == false)
        {
            ARSALPrint.e(MINIDRONEDEVICECONTROLLERANDLIBARCOMMANDS_TAG, "Failed to send MaxVerticalSpeed command.");
        }
        
        return sentStatus;
    }
    
    /**
     * Send a command <code>MaxRotationSpeed</code> of class <code>SpeedSettings</code> in project <code>MiniDrone</code>
     * @param bufferId id of the network buffer used to send
     * @param timeoutPolicy policy when sending timeout
     * @param current Current max rotation speed in degree/s
     */
    protected boolean MiniDroneDeviceController_SendSpeedSettingsMaxRotationSpeed (int bufferId, ARNETWORK_MANAGER_CALLBACK_RETURN_ENUM timeoutPolicy, NetworkNotificationData notificationData, float current)
    {
        ARCOMMANDS_GENERATOR_ERROR_ENUM cmdError = ARCOMMANDS_GENERATOR_ERROR_ENUM.ARCOMMANDS_GENERATOR_OK;
        boolean sentStatus = false;
        ARCommand cmd = new ARCommand();
        
        cmdError = cmd.setMiniDroneSpeedSettingsMaxRotationSpeed (current);
        if (cmdError == ARCOMMANDS_GENERATOR_ERROR_ENUM.ARCOMMANDS_GENERATOR_OK)
        {
            /** send the command */
            sentStatus = sendData (cmd, bufferId, timeoutPolicy, notificationData);
            cmd.dispose();
        }
        
        if (sentStatus == false)
        {
            ARSALPrint.e(MINIDRONEDEVICECONTROLLERANDLIBARCOMMANDS_TAG, "Failed to send MaxRotationSpeed command.");
        }
        
        return sentStatus;
    }
    
    /**
     * Send a command <code>Wheels</code> of class <code>SpeedSettings</code> in project <code>MiniDrone</code>
     * @param bufferId id of the network buffer used to send
     * @param timeoutPolicy policy when sending timeout
     * @param present 1 if present, 0 if not present
     */
    protected boolean MiniDroneDeviceController_SendSpeedSettingsWheels (int bufferId, ARNETWORK_MANAGER_CALLBACK_RETURN_ENUM timeoutPolicy, NetworkNotificationData notificationData, byte present)
    {
        ARCOMMANDS_GENERATOR_ERROR_ENUM cmdError = ARCOMMANDS_GENERATOR_ERROR_ENUM.ARCOMMANDS_GENERATOR_OK;
        boolean sentStatus = false;
        ARCommand cmd = new ARCommand();
        
        cmdError = cmd.setMiniDroneSpeedSettingsWheels (present);
        if (cmdError == ARCOMMANDS_GENERATOR_ERROR_ENUM.ARCOMMANDS_GENERATOR_OK)
        {
            /** send the command */
            sentStatus = sendData (cmd, bufferId, timeoutPolicy, notificationData);
            cmd.dispose();
        }
        
        if (sentStatus == false)
        {
            ARSALPrint.e(MINIDRONEDEVICECONTROLLERANDLIBARCOMMANDS_TAG, "Failed to send Wheels command.");
        }
        
        return sentStatus;
    }
    
    /**
     * Send a command <code>CutOutMode</code> of class <code>Settings</code> in project <code>MiniDrone</code>
     * @param bufferId id of the network buffer used to send
     * @param timeoutPolicy policy when sending timeout
     * @param enable Enable cut out mode (1 if is activate, 0 otherwise)
     */
    protected boolean MiniDroneDeviceController_SendSettingsCutOutMode (int bufferId, ARNETWORK_MANAGER_CALLBACK_RETURN_ENUM timeoutPolicy, NetworkNotificationData notificationData, byte enable)
    {
        ARCOMMANDS_GENERATOR_ERROR_ENUM cmdError = ARCOMMANDS_GENERATOR_ERROR_ENUM.ARCOMMANDS_GENERATOR_OK;
        boolean sentStatus = false;
        ARCommand cmd = new ARCommand();
        
        cmdError = cmd.setMiniDroneSettingsCutOutMode (enable);
        if (cmdError == ARCOMMANDS_GENERATOR_ERROR_ENUM.ARCOMMANDS_GENERATOR_OK)
        {
            /** send the command */
            sentStatus = sendData (cmd, bufferId, timeoutPolicy, notificationData);
            cmd.dispose();
        }
        
        if (sentStatus == false)
        {
            ARSALPrint.e(MINIDRONEDEVICECONTROLLERANDLIBARCOMMANDS_TAG, "Failed to send CutOutMode command.");
        }
        
        return sentStatus;
    }
    
    /**
     * Send a command <code>Test1</code> of class <code>Debug</code> in project <code>MiniDrone</code>
     * @param bufferId id of the network buffer used to send
     * @param timeoutPolicy policy when sending timeout
     * @param t1Args Test 1 argument
     */
    protected boolean MiniDroneDeviceController_SendDebugTest1 (int bufferId, ARNETWORK_MANAGER_CALLBACK_RETURN_ENUM timeoutPolicy, NetworkNotificationData notificationData, byte t1Args)
    {
        ARCOMMANDS_GENERATOR_ERROR_ENUM cmdError = ARCOMMANDS_GENERATOR_ERROR_ENUM.ARCOMMANDS_GENERATOR_OK;
        boolean sentStatus = false;
        ARCommand cmd = new ARCommand();
        
        cmdError = cmd.setMiniDroneDebugDebugTest1 (t1Args);
        if (cmdError == ARCOMMANDS_GENERATOR_ERROR_ENUM.ARCOMMANDS_GENERATOR_OK)
        {
            /** send the command */
            sentStatus = sendData (cmd, bufferId, timeoutPolicy, notificationData);
            cmd.dispose();
        }
        
        if (sentStatus == false)
        {
            ARSALPrint.e(MINIDRONEDEVICECONTROLLERANDLIBARCOMMANDS_TAG, "Failed to send Test1 command.");
        }
        
        return sentStatus;
    }
    
    /**
     * Send a command <code>Test2</code> of class <code>Debug</code> in project <code>MiniDrone</code>
     * @param bufferId id of the network buffer used to send
     * @param timeoutPolicy policy when sending timeout
     * @param t2Args Test 2 argument
     */
    protected boolean MiniDroneDeviceController_SendDebugTest2 (int bufferId, ARNETWORK_MANAGER_CALLBACK_RETURN_ENUM timeoutPolicy, NetworkNotificationData notificationData, byte t2Args)
    {
        ARCOMMANDS_GENERATOR_ERROR_ENUM cmdError = ARCOMMANDS_GENERATOR_ERROR_ENUM.ARCOMMANDS_GENERATOR_OK;
        boolean sentStatus = false;
        ARCommand cmd = new ARCommand();
        
        cmdError = cmd.setMiniDroneDebugDebugTest2 (t2Args);
        if (cmdError == ARCOMMANDS_GENERATOR_ERROR_ENUM.ARCOMMANDS_GENERATOR_OK)
        {
            /** send the command */
            sentStatus = sendData (cmd, bufferId, timeoutPolicy, notificationData);
            cmd.dispose();
        }
        
        if (sentStatus == false)
        {
            ARSALPrint.e(MINIDRONEDEVICECONTROLLERANDLIBARCOMMANDS_TAG, "Failed to send Test2 command.");
        }
        
        return sentStatus;
    }
    
    /**
     * Send a command <code>Test3</code> of class <code>Debug</code> in project <code>MiniDrone</code>
     * @param bufferId id of the network buffer used to send
     * @param timeoutPolicy policy when sending timeout
     * @param t3Args Test 3 argument
     */
    protected boolean MiniDroneDeviceController_SendDebugTest3 (int bufferId, ARNETWORK_MANAGER_CALLBACK_RETURN_ENUM timeoutPolicy, NetworkNotificationData notificationData, byte t3Args)
    {
        ARCOMMANDS_GENERATOR_ERROR_ENUM cmdError = ARCOMMANDS_GENERATOR_ERROR_ENUM.ARCOMMANDS_GENERATOR_OK;
        boolean sentStatus = false;
        ARCommand cmd = new ARCommand();
        
        cmdError = cmd.setMiniDroneDebugDebugTest3 (t3Args);
        if (cmdError == ARCOMMANDS_GENERATOR_ERROR_ENUM.ARCOMMANDS_GENERATOR_OK)
        {
            /** send the command */
            sentStatus = sendData (cmd, bufferId, timeoutPolicy, notificationData);
            cmd.dispose();
        }
        
        if (sentStatus == false)
        {
            ARSALPrint.e(MINIDRONEDEVICECONTROLLERANDLIBARCOMMANDS_TAG, "Failed to send Test3 command.");
        }
        
        return sentStatus;
    }
    
}

// END GENERATED CODE
