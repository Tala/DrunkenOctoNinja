<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>libARStream: libARStream Documentation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libARStream
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">libARStream Documentation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="VID_intro_sec"></a>
Introduction</h1>
<p>The ARStream library provides interface to send and receive a data stream through an <a class="elRef" doxygen="/Users/d.bertrand/Documents/SDKGerritCompiled/ARSDKBuildUtils/Targets/Unix/Build/Doc/libARNetwork/libARNetwork.tag:../../libARNetwork/html/" href="../../libARNetwork/html/ARNETWORK__Manager_8h.html#a3cd7bd69cd0a9bc49ad5422887f3dc5a">ARNETWORK_Manager_t</a> object.</p>
<p>The ARStream library is designed to transmit h.264 video frames, but may in fact be used for any kind of data.</p>
<p>The ARStream library use two different objects (<a class="el" href="ARSTREAM__Sender_8h.html#a10fd0b4d4d23202e08626434f3b3479f">ARSTREAM_Sender_t</a> and <a class="el" href="ARSTREAM__Reader_8h.html#a24e2c6eda094b5f79a9bd3c8a2aa5604">ARSTREAM_Reader_t</a>) for both ends of the data stream.</p>
<p>Multiple ARStream objects can share the same <a class="elRef" doxygen="/Users/d.bertrand/Documents/SDKGerritCompiled/ARSDKBuildUtils/Targets/Unix/Build/Doc/libARNetwork/libARNetwork.tag:../../libARNetwork/html/" href="../../libARNetwork/html/ARNETWORK__Manager_8h.html#a3cd7bd69cd0a9bc49ad5422887f3dc5a">ARNETWORK_Manager_t</a>, allowing bidirectionnal streams or multiple streams to be achieved.</p>
<dl class="section note"><dt>Note</dt><dd>The ARStream library does not work on BLE networks.</dd></dl>
<h1><a class="anchor" id="VID_read_flow_sec"></a>
ARStream Reader usage</h1>
<p>The typical use flow for an ARStream Reader application is the following:</p>
<h2><a class="anchor" id="VID_R_arnet_subsec"></a>
1&gt; Provide an initialized ARNetwork instance</h2>
<p>An <a class="el" href="ARSTREAM__Reader_8h.html#a24e2c6eda094b5f79a9bd3c8a2aa5604">ARSTREAM_Reader_t</a> instance uses an <a class="elRef" doxygen="/Users/d.bertrand/Documents/SDKGerritCompiled/ARSDKBuildUtils/Targets/Unix/Build/Doc/libARNetwork/libARNetwork.tag:../../libARNetwork/html/" href="../../libARNetwork/html/ARNETWORK__Manager_8h.html#a3cd7bd69cd0a9bc49ad5422887f3dc5a">ARNETWORK_Manager_t</a> instance to read frames and send acknowledges on the network.</p>
<p>The <a class="elRef" doxygen="/Users/d.bertrand/Documents/SDKGerritCompiled/ARSDKBuildUtils/Targets/Unix/Build/Doc/libARNetwork/libARNetwork.tag:../../libARNetwork/html/" href="../../libARNetwork/html/ARNETWORK__Manager_8h.html#a3cd7bd69cd0a9bc49ad5422887f3dc5a">ARNETWORK_Manager_t</a> must also have properly initialized buffers (1 input for stream ack, 1 output for stream data). To create these buffers, the ARStream library exports functions (<a class="el" href="ARSTREAM__Reader_8h.html#af237ba7e564c1e536ee2173476cac9ae">ARSTREAM_Reader_InitStreamDataBuffer</a> and <a class="el" href="ARSTREAM__Reader_8h.html#ae83d8759f782346254b18271af171be0">ARSTREAM_Reader_InitStreamAckBuffer</a>) to initialize the <a class="elRef" doxygen="/Users/d.bertrand/Documents/SDKGerritCompiled/ARSDKBuildUtils/Targets/Unix/Build/Doc/libARNetwork/libARNetwork.tag:../../libARNetwork/html/" href="../../libARNetwork/html/structARNETWORK__IOBufferParam__t.html">ARNETWORK_IOBufferParam_t</a> structures with the good settings.</p>
<dl class="section note"><dt>Note</dt><dd>If your network will use multiple <a class="el" href="ARSTREAM__Reader_8h.html#a24e2c6eda094b5f79a9bd3c8a2aa5604">ARSTREAM_Reader_t</a>, it must have one pair of buffers for each instance.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a href="../../libARNetwork/html/index.html" target="_blank">ARNetwork Documentation</a></dd></dl>
<h2><a class="anchor" id="VID_R_create_subsec"></a>
2&gt; Create the reader</h2>
<p>The <a class="el" href="ARSTREAM__Reader_8h.html#a24e2c6eda094b5f79a9bd3c8a2aa5604">ARSTREAM_Reader_t</a> can now be properly created, using the <a class="el" href="ARSTREAM__Reader_8h.html#a8d8b8868adf53ee0b0681ddc2377c7c4">ARSTREAM_Reader_New</a> function.</p>
<p>This function takes two important things as parameters:</p>
<p>The frame buffer will be used to hold the first frame.</p>
<p>The callback (<a class="el" href="ARSTREAM__Reader_8h.html#a716a0087c891b379c6c68448bc374378">ARSTREAM_Reader_FrameCompleteCallback_t</a>) will be called every time a frame is complete. It may also be called on different events (see <a class="el" href="ARSTREAM__Reader_8h.html#ae7b0aef7f05e99d271fcb04c81975eda">eARSTREAM_READER_CAUSE</a>). The callback will also provide new frame buffers to the library</p>
<dl class="section note"><dt>Note</dt><dd>The callback is called in the <a class="el" href="ARSTREAM__Reader_8h.html#a24e2c6eda094b5f79a9bd3c8a2aa5604">ARSTREAM_Reader_t</a> data thread. Processing in the callback should be minimal to avoid introducing delay in the stream.</dd>
<dd>
If the callback does a frame copy (which is not the recommanded behavior), it can return the same frame buffer for the next frame. In other cases, a new buffer must be used (like in <a href="https://en.wikipedia.org/wiki/Multiple_buffering" target="_blank">multi buffering</a>)</dd></dl>
<h2><a class="anchor" id="VID_R_start_th_subsec"></a>
3&gt; Start the readers threads</h2>
<p>The <a class="el" href="ARSTREAM__Reader_8h.html#a24e2c6eda094b5f79a9bd3c8a2aa5604">ARSTREAM_Reader_t</a> uses two internal threads to perform the network operations. The application can use any threading framework to launch the internal threads, but in any case each one must be started once and only once.</p>
<p>The threads entry point are <a class="el" href="ARSTREAM__Reader_8h.html#afc9b0affb026e4cf90e09134e1b6d578">ARSTREAM_Reader_RunDataThread</a> and <a class="el" href="ARSTREAM__Reader_8h.html#a129ecb448f4ed2d2f60bfd36caf68b7b">ARSTREAM_Reader_RunAckThread</a>.</p>
<p>If your application does not require any special threading framework, it can use the libARSAL Thread module.</p>
<dl class="section note"><dt>Note</dt><dd>To ease the closing process, the threads should not be created in detached mode.</dd></dl>
<h2><a class="anchor" id="VID_R_use_subsec"></a>
4&gt; Use the reader</h2>
<p>The <a class="el" href="ARSTREAM__Reader_8h.html#a24e2c6eda094b5f79a9bd3c8a2aa5604">ARSTREAM_Reader_t</a> has a full synchronous approach.</p>
<p>After thread starts, the <a class="el" href="ARSTREAM__Reader_8h.html#a24e2c6eda094b5f79a9bd3c8a2aa5604">ARSTREAM_Reader_t</a> will automatically call its <a class="el" href="ARSTREAM__Reader_8h.html#a716a0087c891b379c6c68448bc374378">ARSTREAM_Reader_FrameCompleteCallback_t</a> callback every time a complete frame is received.</p>
<h2><a class="anchor" id="VID_R_stop_th_subsec"></a>
5&gt; Stop the readers threads</h2>
<p>To stop the <a class="el" href="ARSTREAM__Reader_8h.html#a24e2c6eda094b5f79a9bd3c8a2aa5604">ARSTREAM_Reader_t</a> threads, use the <a class="el" href="ARSTREAM__Reader_8h.html#a8219ee9016e2919425f0859390a7bce1">ARSTREAM_Reader_StopReader</a> function. This function causes the threads to return as soon as possible. Thread returns may be delayed by ARNetwork calls for a time up to the internally set timeout (typically 1 second).</p>
<p>To ensure that the threads are correctly stopped, the application should join them (any order works).</p>
<p>When stopping, the data thread will call the <a class="el" href="ARSTREAM__Reader_8h.html#a716a0087c891b379c6c68448bc374378">ARSTREAM_Reader_FrameCompleteCallback_t</a> a last time with <a class="el" href="ARSTREAM__Reader_8h.html#ae7b0aef7f05e99d271fcb04c81975edaa9d15639a009297f81d30e0c3377bec0e">ARSTREAM_READER_CAUSE_CANCEL</a> as the cause, letting know the application that the frame buffer is no longer referenced and can be freed.</p>
<h2><a class="anchor" id="VID_R_clean_sec"></a>
6&gt; Close the reader</h2>
<p>The <a class="el" href="ARSTREAM__Reader_8h.html#a24e2c6eda094b5f79a9bd3c8a2aa5604">ARSTREAM_Reader_t</a> object can then be destroyed using <a class="el" href="ARSTREAM__Reader_8h.html#a6cba9caad19cfe5451241c47247b424c">ARSTREAM_Reader_Delete</a> function.</p>
<p>This call is mandatory, as it reclaims all allocated memory.</p>
<h1><a class="anchor" id="VID_send_flow_sec"></a>
ARStream Sender usage</h1>
<p>The typical use flow for an ARStream Sender application is the following:</p>
<h2><a class="anchor" id="VID_S_arnet_subsec"></a>
1&gt; Provide an initialized ARNetwork instance</h2>
<p>An <a class="el" href="ARSTREAM__Sender_8h.html#a10fd0b4d4d23202e08626434f3b3479f">ARSTREAM_Sender_t</a> instance uses an <a class="elRef" doxygen="/Users/d.bertrand/Documents/SDKGerritCompiled/ARSDKBuildUtils/Targets/Unix/Build/Doc/libARNetwork/libARNetwork.tag:../../libARNetwork/html/" href="../../libARNetwork/html/ARNETWORK__Manager_8h.html#a3cd7bd69cd0a9bc49ad5422887f3dc5a">ARNETWORK_Manager_t</a> instance to read acknowledges and send frames on the network.</p>
<p>The <a class="elRef" doxygen="/Users/d.bertrand/Documents/SDKGerritCompiled/ARSDKBuildUtils/Targets/Unix/Build/Doc/libARNetwork/libARNetwork.tag:../../libARNetwork/html/" href="../../libARNetwork/html/ARNETWORK__Manager_8h.html#a3cd7bd69cd0a9bc49ad5422887f3dc5a">ARNETWORK_Manager_t</a> must also have properly initialized buffers (1 output for stream ack, 1 input for stream data). To create these buffers, the ARStream library exports functions (<a class="el" href="ARSTREAM__Sender_8h.html#a153ec12bc13015070bd1913cd69e6f4b">ARSTREAM_Sender_InitStreamDataBuffer</a> and <a class="el" href="ARSTREAM__Sender_8h.html#a3fe39c7a529b90d52292a3a3230f693f">ARSTREAM_Sender_InitStreamAckBuffer</a>) to initialize the <a class="elRef" doxygen="/Users/d.bertrand/Documents/SDKGerritCompiled/ARSDKBuildUtils/Targets/Unix/Build/Doc/libARNetwork/libARNetwork.tag:../../libARNetwork/html/" href="../../libARNetwork/html/structARNETWORK__IOBufferParam__t.html">ARNETWORK_IOBufferParam_t</a> structures with the good settings.</p>
<dl class="section note"><dt>Note</dt><dd>If your network will use multiple <a class="el" href="ARSTREAM__Sender_8h.html#a10fd0b4d4d23202e08626434f3b3479f">ARSTREAM_Sender_t</a>, it must have one pair of buffers for each instance.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a href="../../libARNetwork/html/index.html" target="_blank">ARNetwork Documentation</a></dd></dl>
<h2><a class="anchor" id="VID_S_create_subsec"></a>
2&gt; Create the sender</h2>
<p>The <a class="el" href="ARSTREAM__Sender_8h.html#a10fd0b4d4d23202e08626434f3b3479f">ARSTREAM_Sender_t</a> can now be properly created, using the <a class="el" href="ARSTREAM__Sender_8h.html#a9d1cd19879d1b648442ce051e7ac5820">ARSTREAM_Sender_New</a> function.</p>
<p>This function takes two important things as parameters:</p>
<p>The frame buffer size is the number of frames that can be bufferized by the <a class="el" href="ARSTREAM__Sender_8h.html#a10fd0b4d4d23202e08626434f3b3479f">ARSTREAM_Sender_t</a> instance.</p>
<p>The callback (<a class="el" href="ARSTREAM__Sender_8h.html#ad10c23eb61455d64f318ae005ec93075">ARSTREAM_Sender_FrameUpdateCallback_t</a>) will be called every time a frame buffer reference will be dropped by the <a class="el" href="ARSTREAM__Sender_8h.html#a10fd0b4d4d23202e08626434f3b3479f">ARSTREAM_Sender_t</a>. This will typically happen when the <a class="el" href="ARSTREAM__Sender_8h.html#a10fd0b4d4d23202e08626434f3b3479f">ARSTREAM_Sender_t</a> received a full acknowledge for a frame, but can also happen when flushing the frame queue. (see <a class="el" href="ARSTREAM__Sender_8h.html#ac3e6c617607473990c705a0d081dd01d">eARSTREAM_SENDER_STATUS</a>)</p>
<dl class="section note"><dt>Note</dt><dd>The callback is called in one of the <a class="el" href="ARSTREAM__Sender_8h.html#a10fd0b4d4d23202e08626434f3b3479f">ARSTREAM_Sender_t</a> threads. Processing in the callback should be minimal to avoid introducing delay in the stream.</dd></dl>
<h2><a class="anchor" id="VID_S_start_th_subsec"></a>
3&gt; Start the senders threads</h2>
<p>The <a class="el" href="ARSTREAM__Sender_8h.html#a10fd0b4d4d23202e08626434f3b3479f">ARSTREAM_Sender_t</a> uses two internal threads to perform the network operations. The application can use any threading framework to launch the internal threads, but in any case each one must be started once and only once.</p>
<p>The threads entry point are <a class="el" href="ARSTREAM__Sender_8h.html#abefd92cdf525c2133c6f8800a8611ca9">ARSTREAM_Sender_RunDataThread</a> and <a class="el" href="ARSTREAM__Sender_8h.html#ae61e9e48df5fb874640d51dc561171c8">ARSTREAM_Sender_RunAckThread</a>.</p>
<p>If your application does not require any special threading framework, it can use the libARSAL Thread module.</p>
<dl class="section note"><dt>Note</dt><dd>To ease the closing process, the threads should not be created in detached mode.</dd></dl>
<h2><a class="anchor" id="VID_S_use_subsec"></a>
4&gt; Use the sender</h2>
<p>To send a new frame through the <a class="el" href="ARSTREAM__Sender_8h.html#a10fd0b4d4d23202e08626434f3b3479f">ARSTREAM_Sender_t</a>, use the <a class="el" href="ARSTREAM__Sender_8h.html#a432cf3ba0832728e7e297e109b9ae4fe">ARSTREAM_Sender_SendNewFrame</a> function. If this function does not return an error, then the frame buffer will be referenced by the <a class="el" href="ARSTREAM__Sender_8h.html#a10fd0b4d4d23202e08626434f3b3479f">ARSTREAM_Sender_t</a> until the <a class="el" href="ARSTREAM__Sender_8h.html#ad10c23eb61455d64f318ae005ec93075">ARSTREAM_Sender_FrameUpdateCallback_t</a> callback is called for it.</p>
<p>This function can also return (through an optionnal pointer parameter) the number of buffered frames. This information can be used to adapt the stream quality to the network. (If the buffer grows, it may be because the network can not handle the stream bandwidth)</p>
<p>This function can also flush all previously sent frame (typically when the new frame is an h.264 I-Frame).</p>
<h2><a class="anchor" id="VID_S_stop_th_subsec"></a>
5&gt; Stop the senders threads</h2>
<p>To stop the <a class="el" href="ARSTREAM__Sender_8h.html#a10fd0b4d4d23202e08626434f3b3479f">ARSTREAM_Sender_t</a> threads, use the <a class="el" href="ARSTREAM__Sender_8h.html#a034b1ab574d7b4b306c85e66efe872d2">ARSTREAM_Sender_StopSender</a> function. This function causes the threads to return as soon as possible. Thread returns may be delayed by ARNetwork calls for a time up to the internally set timeout (typically 1 second).</p>
<p>To ensure that the threads are correctly stopped, the application should join them (any order works).</p>
<p>When stopping, the data thread will call the <a class="el" href="ARSTREAM__Sender_8h.html#ad10c23eb61455d64f318ae005ec93075">ARSTREAM_Sender_FrameUpdateCallback_t</a> on all buffered frames with <a class="el" href="ARSTREAM__Sender_8h.html#ac3e6c617607473990c705a0d081dd01dab1d823a098890ea715536d5da93a5d2f">ARSTREAM_SENDER_STATUS_FRAME_CANCEL</a> as the status, letting know the application that the frame buffers are no longer referenced and can be freed.</p>
<h2><a class="anchor" id="VID_S_clean_sec"></a>
6&gt; Close the sender</h2>
<p>The <a class="el" href="ARSTREAM__Sender_8h.html#a10fd0b4d4d23202e08626434f3b3479f">ARSTREAM_Sender_t</a> object can then be destroyed using <a class="el" href="ARSTREAM__Sender_8h.html#ae1c5bab26c9280a0b80016ba892b0949">ARSTREAM_Sender_Delete</a> function.</p>
<p>This call is mandatory, as it reclaims all allocated memory.</p>
<h1><a class="anchor" id="VID_utility_sec"></a>
Utility functions</h1>
<p>Both the <a class="el" href="ARSTREAM__Sender_8h.html#a10fd0b4d4d23202e08626434f3b3479f">ARSTREAM_Sender_t</a> and <a class="el" href="ARSTREAM__Reader_8h.html#a24e2c6eda094b5f79a9bd3c8a2aa5604">ARSTREAM_Reader_t</a> implements an efficiency estimation function.</p>
<p>The <a class="el" href="ARSTREAM__Sender_8h.html#a10fd0b4d4d23202e08626434f3b3479f">ARSTREAM_Sender_t</a> function (<a class="el" href="ARSTREAM__Sender_8h.html#abf569a68173c7750b202876f1e716c49">ARSTREAM_Sender_GetEstimatedEfficiency</a>) computes the ratio of frame fragments actually sent on the network, over the number of frame fragments that would have been sent in an ideal case (no network losses).</p>
<p>The <a class="el" href="ARSTREAM__Reader_8h.html#a24e2c6eda094b5f79a9bd3c8a2aa5604">ARSTREAM_Reader_t</a> function (<a class="el" href="ARSTREAM__Reader_8h.html#a94003b88b2f03e7f0cc8e6d3b5f0cf7f">ARSTREAM_Reader_GetEstimatedEfficiency</a>) computes the ratio of frame fragments received from the network, over the number of frame fragments actually used to construct output frames (i.e. it counts the fragments that had useless retries from the <a class="el" href="ARSTREAM__Sender_8h.html#a10fd0b4d4d23202e08626434f3b3479f">ARSTREAM_Sender_t</a>)</p>
<p>Due to the difference in calculation, the efficiency value for both ends of the stream will be different. Typically, the <a class="el" href="ARSTREAM__Sender_8h.html#a10fd0b4d4d23202e08626434f3b3479f">ARSTREAM_Sender_t</a> estimated efficiency should be lower, as the actually dropped frames fragments are not counted by the <a class="el" href="ARSTREAM__Reader_8h.html#a24e2c6eda094b5f79a9bd3c8a2aa5604">ARSTREAM_Reader_t</a> estimation. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Aug 6 2015 16:14:34 for libARStream by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
